


module sickomode(
  input clk,
  input resetn,
  input start,
  input startdraw,
  input [5:0] offset,
  input [2:0] lane_0,
  input [5:0] master_state,
  output all_done,
  output [8:0] x_out,
  output [7:0] y_out,
  output [2:0] c_out
);
    wire finish_draw, finish_erase;
    wire [8:0] draw_lane1_x;
    wire [7:0] draw_lane1_y;
    wire [8:0] erase_lane1_x;
    wire [7:0] erase_lane1_y;

    wire startdraw, starterase;

    draw drawlane1 (
		.clk(clk),
		.startdraw(startdraw),
		.lane_id(4'b0000),
		.lane_above(line_0[2:0]),
		.offset(offset[5:0]),
		.x_out(draw_0_x[8:0]),
		.y_out(draw_0_y[7:0]),
		.c_out(3'b100),
		.draw_done(draw_done[0])
	);

    wire [4:0] current_state;
    display_controller controller(
        .clk(clk),
        .resetn(resetn),
        .master_state(master_state),
        .finish_draw(finish_draw),
        .finish_erase(finish_erase),
        // .draw_colour(3'b100),
        .draw_lanex1(draw_lane1_x),
        .draw_laney1(draw_lane1_y),
        .erase_lanex1(draw_lane1_x),
        .erase_laney1(draw_lane1_y)
        .all_done(all_done),
        .godraw(startdraw),
        .goerase(goerase),
        .x_out(x_out),
        .y_out(y_out),
        .c_out(c_out)
        .currstate(current_state)
    );

endmodule // sickomode

module display_controller(input clk, 
            input resetn, 
            input start, 
            input startdraw,
            input [7:0] draw_lanex1,
            input [7:0] erase_lanex1,
            input [8:0] draw_laney1,
            input [8:0] erase_laney1,
            input [5:0] master_state,
            output reg godraw, goerase,
            output [8:0] x_out,
            output [7:0] y_out,
            output [2:0] c_out,
            output [4:0] currstate,
            output reg all_done
            );

        reg [2:0] next_state;
        localparam  IDLE        = 3'd0,
                    ERASE_1     = 3'd1,
                    DRAW_1      = 3'd2,
                    DONE        = 3'd3;

        initial curr_state = IDLE;
        always@(*)
        begin: state_table
            case(curr_state)
                WAIT: next_state = startdraw ? ERASE_1 : IDLE;
                ERASE_1: next_state = erase1_done ? DRAW_1 : ERASE_1;
                DRAW_1: next_state = draw1done ? DONE : DRAW_1;
                DONE: next_state = startdraw ? DONE : WAIT;
                default : next_state = WAIT;
            endcase
        end //state_table

        always @(*)
        begin: enable_signals
            all_done = 1'b0;
            case(curr_state)
                ERASE_1 : begin
                    goerase = 1'b1; // enables erasing of lane 1
                    x_out = erase_lanex1;
                    y_out = erase_laney1;
                    c_out = 2'b000; // black like the background
                    end
                DRAW_1: begin
                    godraw = 1'b1 //enables drawing of lane 1
                    x_out = draw_lanex1;
                    y_out = draw_laney1;
                    c_out = 2'b111; // white for now, change later
                    end
                DONE: begin
                    all_done = 1'b1;
                    x_out = 9'b0; // reset
                    y_out = 9'b0;
                    colour_out = 3'b111; // draw white for now
                    end
                default: begin
                    x_out = 9'b0;
                    y_out = 8'b0;
                    colour_out = 3'b111;
                    end 
            endcase
        end

        always @(posedge clock)
            begin: state_FFs
            if (!resetn | (!start & master_state == 6'd0))
                current_state <= WAIT;
            else
                current_state <= next_state;
endmodule

module draw(
    input clk,
    input startdraw,
    input [2:0] lane_number,
    input [2:0] lane_above,
    input [5:0] offset,
    output reg [8:0] x_out,
    output reg [7:0] y_out,
    output reg [2:0] colour_out
    output reg finish_draw
    );

    always @(*)
		lane_id_offset = lane_id * 40;
		
	always @(*)
		y_out = lane_id_offset + offset;

    always @(posedge clk)
    begin
        if (startdraw == 1'b0) begin
            case (lane_above)
				3'b000: begin
					x_out <= 140; 
					finish_draw <= 1'b0;
					c_out <= 3'b111;
				end
				3'b001: begin
					x_out <= 120;
					finish_draw <= 1'b0;
					c_out <= 3'b000;
				end
				3'b010: begin
					x_out <= 140;
					finish_draw <= 1'b0;
					c_out <= 3'b000;
				end
				3'b011: begin
					x_out <= 160;
					finish_draw <= 1'b0;
					c_out <= 3'b000;
				end
				3'b100: begin
					x_out <= 180;
					finish_draw <= 1'b0;
					c_out <= 3'b000;
				end
				default: begin
					x_out <= 140;
					finish_draw <= 1'b0;
					c_out <= 3'b111;
				end
			endcase
        end // if
        else begin
            case (lane_above)
				3'b000: //do nothing
					finish_draw <= 1'b1;
				3'b001: begin
					if (x_out == 139)
						finish_draw <= 1'b1;
					else
						x = x + 1;
				end
				3'b010: begin
					if (x == 159)
						finish_draw <= 1'b1;
					else
						x = x + 1;
				end
				3'b011: begin
					if (x == 179)
						finish_draw <= 1'b1;
					else
						x_out = x_out + 1;
				end
				3'b100: begin
					if (x == 199)
						finish_draw <= 1'b1;
					else
						x_out = x_out + 1;
				end
				default:
					finish_draw <= 1'b1;
			endcase
        end // else
    end // always
endmodule

module erase (
	input clock,
		erase_enable,
	input [3:0] line_id,
	input [2:0] line_below,
	input [5:0] offset,

	output reg [8:0] x_out,
	output reg [7:0] y_out,
	output c_out,
	output reg erase_done
	);
	
	reg [7:0] line_id_offset;
	
	assign c_out = 1'b000; //always draw black
	
	always @(*)
		line_id_offset = line_id * 40;
		
	always @(*)
		y_out = line_id_offset + offset;
		
	always@(posedge clock)
	begin
		if (!erase_enable)
			//set up in preparation for signal
			case (line_below)
				3'b000: begin
					x_out <= 140; 
					erase_done <= 1'b0;
				end
				3'b001: begin
					x_out <= 120;
					erase_done <= 1'b0;
				end
				3'b010: begin
					x_out <= 140;
					erase_done <= 1'b0;
				end
				3'b011: begin
					x_out <= 160;
					erase_done <= 1'b0;
				end
				3'b100: begin
					x_out <= 180;
					erase_done <= 1'b0;
				end
				default: begin
					x_out <= 140;
					erase_done <= 1'b0;
				end
			endcase
		else 
			//start incrementing
			case (line_below)
				3'b000: //do nothing
					erase_done <= 1'b1;
				3'b001: begin
					if (x_out == 139)
						erase_done <= 1'b1;
					else
						x_out = x_out + 1;
				end
				3'b010: begin
					if (x_out == 159)
						erase_done <= 1'b1;
					else
						x_out = x_out + 1;
				end
				3'b011: begin
					if (x_out == 179)
						erase_done <= 1'b1;
					else
						x_out = x_out + 1;
				end
				3'b100: begin
					if (x_out == 199)
						erase_done <= 1'b1;
					else
						x_out = x_out + 1;
				end
				default:
					erase_done <= 1'b1;
			endcase
	end //always block
	
endmodule

